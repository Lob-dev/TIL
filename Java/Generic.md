2020.10.29

<br/>

**기존 Java에서는 상황에 따라 각기 다른 데이터를 다루기 위해 최상위 클래스인 Object 를 사용하여 코드를 작성하곤 하였다.** 

```java
class DataDto{

    private Object data;

    public setData(Object data) {
				this.data = data;
		}

    public Object getData() {
				return data;
		}
}
```

그를 통해서 어떠한 데이터라도 받아 저장할 수 있었으나 몇가지 문제가 있었는데.

- **저장했던 값을 사용해야 할 때 명시적으로 캐스팅을 해서 사용해야 한다.**
- **잘못된 캐스팅을 통한 오류가 발생할 수 있다. (String → Integer 등..)**
- **들어온 타입에 대한 검증하는 로직이 추가로 들어가야한다. ( instanceof 결국 런타임에서 발견 )**
- **에러의 유무를 컴파일 단계에서 체크할 수 없다. (사전에 방지할 수 없다.)**

**즉 모호하고 찾기 어려운 잠재적인 오류를 가지게 된다. (해결할 수 있는 문제임에도 불구하고.)**

컴파일 시에 타입 체크를 해야 사전에 개발자의 실수를 방지할 수 있고, 

명시적인 캐스팅에 대한 런타임 에러가 해결되어야 한다.

**그래서 JDK 1.5 에서는 Generic이 등장하게 되었다.**

<br/>

**<T>  타입**

- **가상의 타입 (구현된 타입도 가능하다.)**

<br/>

**제네릭의 관례** 

- **E : Element = Collection**
- **K : Key**
- **N : Number**
- **T : Type Parameter**
- **V : Value**
- **S,U,V : 두번 째, 세 번째, 네 번째에 선언된 타입**

 ****

```java
class Data <T>{

    private T data;

    public void setData(T data) {
        this.data = data;
    }

    public T getData() {
        return data;
    }
}
```

**Generic은 해당 기능들을 제공한다.**

- **컴파일러를 통해 타입 체크가 가능하다. 즉 컴파일 과정에서 문제를 제거할 수 있다.**
- 컴파일 시점에서 사용되는 타입을 체크하여 **해당 타입에 맞게 컴파일한다.**
- **일반적으로 캐스팅 비용과 타입 체크의 비용이 들어가지 않는다.**
- **타입의 경계**를 **지정하여 제한할 수 있다.**

<br/>

**Generic을 사용하게 발생하는 제약으론**

- **Primitive Type을 사용할 수 없다.**
- **컴파일 이후에 타입이 소거되기 때문에 런타임에서 타입 체크를 할 수 없다. - Non-Reifiable**
    - 해당 문제는 **Java 간의 하위 호환성을 위해 VM에서 지우는 방식**이다.
    - 타입 소거로 인해 **캐스팅하는 코드가 발생할 수 있다.**

**등이 있다.**
2020.11.09

<br/>

**Lock?**

1.5 에 추가된  Concurrent 패키지의 Lock 은 기존의 synchronized 블럭을 확장한 좀 더 유연하고 정교한 동기화 방식이다.

<br/>

**synchronized 와의 차이점**

- 별도의 synchronized Statement 등을 만들어 사용하던 방식을 사용하지 않고도 메서드를 통하여서 임계영역을 지정, 제공할 수 있다. (lock(), unlock())
- **synchronized 를 사용할 때 발생했던 문제인 기아상태에 대한 해결책을 지원한다.**
- 각 쓰레드에게 공정성이란 속성을 제공한다. - fairness Property 
    - **synchronized 는 쓰레드 들의 진입 순서를 보장하지 않는다.**
        
- tryLock() 을 통해 해당 임계 영역 접근 불가능할 때 쓰레드를 차단하지 않고 가능한 경우에만 잠금을 획득하게끔 지원하고, 쓰레드가 차단된 시간을 감소시킵니다.
- 임계 영역에 대한 접근 권한을 얻기 위해 대기 중인 스레드는 인터럽트할 수 없다.

synchronized 는 쓰레드의 진입 순서를 보장하지 않는 반면에 Lock은 진입 순서를 보장한다.

<br/>

- **추가 - Thread의 기아상태**
    - 다수의 쓰레드가 동일한 임계영역에 계속해서 접근을 한다면, 하나 이상의 쓰레드가 접근 권한을 받지 못하는 경우가 발생할 수 있다. (기아 상태)

    - **기아 상태의 원인**
         1. **높은 우선 순위에 따른 쓰레드들의 CPU 독점**
                        - 자바에선 쓰레드들 각각에 대한 우선순위를 설정할 수 있다.  (1~10)
                        
        1. **권한 선점 실패로 계속되는 Block 상태**
                        - 쓰레드가 임계영역으로 진입하기 위해 계속 접근 시도를 하지만, 다른 쓰레드들의 접근 권한 획득으로 인하여 계속해서 Block된 상태를 말한다.
        2. **wait 호출을 통한 쓰레드 대기 상태**
                        - 둘 이상의 쓰레드가 동일한 객체의 wait 호출로 인하여 대기 상태에 놓였을 때. notify 메서드는 어떤 스레드를 깨울 것인지 알 수 없다.
            - 깨어나지 못하고 계속 대기할 수 있다.

    - 해당 문제를 해결하기 위해선 공정성의 개념을 지원하여야 한다.
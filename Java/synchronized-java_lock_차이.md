2020.11.09

<br/>

**Lock?**

1.5 에 추가된  Concurrent 패키지의 Lock 은 기존의 synchronized 블럭을 확장한 좀 더 유연하고 정교한 동기화 방식이다.

<br/>

**synchronized 와의 차이점**

- 별도의 synchronized Statement 등을 만들어 사용하던 방식을 사용하지 않고도 메서드를 통하여서 임계영역을 지정, 제공할 수 있다. (lock(), unlock())
- **synchronized 를 사용할 때 발생했던 문제인 기아상태에 대한 해결책을 지원한다.**
- 각 쓰레드에게 공정성이란 속성을 제공한다. - fairness Property 
    - **synchronized 는 쓰레드 들의 진입 순서를 보장하지 않는다.**
        
- tryLock() 을 통해 해당 임계 영역 접근 불가능할 때 쓰레드를 차단하지 않고 가능한 경우에만 잠금을 획득하게끔 지원하고, 쓰레드가 차단된 시간을 감소시킬 수 있다.
- 임계 영역에 대한 접근 권한을 얻기 위해 대기 중인 스레드는 인터럽트할 수 없다.

synchronized 는 쓰레드의 진입 순서를 보장하지 않는 반면에 Lock은 진입 순서를 보장한다.

<br/>

++ 내용 추가 2020.11.19

**Lock 을 왜 쓰는가?**
싱크로나이즈를 사용할 때 메서드 단위의 설정을 걸어버리면 성능 문제가 발생하고, 작은 범위에 동기화를 위해 싱크로나이즈 블록을 사용한다면 동기화 문제를 제대로 해결할 수 없거나 블록만으로 커버할 수 없는 상황이 있을 수 있다. 이때 좀 더 유연한 동기화 처리를 위해 사용하는 것이 Lock이다.

**RentrantLock?**
명시적 락을 걸음으로써 세부적인 (동기화 시작 지점과 끝 지점을 설정등)동기화 처리를 할 수 있으며, 기존 join, notify, notifyAll 을 지원하기 위해 Condition 클래스를 사용한다.
그외에도 기아 상태를 방지하기 위해 메서드를 통한 공정 방법을 설정할 수 있고, 시간 제한이나 인터럽트를 걸 수 있는 락 등까지 제공한다.

코드가 단일 블록에서 끝나지 않는 경우, 타임 아웃을 지정한 락을 사용해야하는 경우, 쓰레드를 대기상태에 빠트리지 않고 인터럽트를 걸어야하는 경우, 쓰레드간의 경쟁을 공정성있게 처리해야하는 경우에 사용한다.

**추가적으로 유틸리티 성 메서드를 지님으로써 사용하기 좋다.**

- 대기 중인 쓰레드의 수를 확인하는 메서드
- 대기 중인 쓰레드를 가져오는 메서드

<br/>
<br/>

- **추가 - Thread의 기아상태**
    - 다수의 쓰레드가 동일한 임계영역에 계속해서 접근을 한다면, 하나 이상의 쓰레드가 접근 권한을 받지 못하는 경우가 발생할 수 있다. (기아 상태)

    - **기아 상태의 원인**
         1. **높은 우선 순위에 따른 쓰레드들의 CPU 독점**
                        - 자바에선 쓰레드들 각각에 대한 우선순위를 설정할 수 있다.  (1~10)
                        
        1. **권한 선점 실패로 계속되는 Block 상태**
                        - 쓰레드가 임계영역으로 진입하기 위해 계속 접근 시도를 하지만, 다른 쓰레드들의 접근 권한 획득으로 인하여 계속해서 Block된 상태를 말한다.
        2. **wait 호출을 통한 쓰레드 대기 상태**
                        - 둘 이상의 쓰레드가 동일한 객체의 wait 호출로 인하여 대기 상태에 놓였을 때. notify 메서드는 어떤 스레드를 깨울 것인지 알 수 없다.
            - 깨어나지 못하고 계속 대기할 수 있다.

    - 해당 문제를 해결하기 위해선 공정성의 개념을 지원하여야 한다.
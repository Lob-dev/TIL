2020.11.02

<br/>

### Equals를 재정의 해야하는 이유? 

- **논리적인 동치성을 검증해야 할 때.**
    - Custom Class 를 만들었을 때, 해당 Class가 여러개의 인스턴스가 만들어지는 경우에 값을 기준으로 비교해야한다면 Equals 를 재정의 하여야 한다.
    - Equals 를 통해 True를 반환 받았다면, 두 객체는 같은 Hashcode 값을 가져야 한다.
        - Hashcode도 Equals 와 동일한 규약을 지니고 재정의 되어야한다.

- **재정의 시 지켜야할 규약?**
    - **반사성 : 객체는 자기 자신과 같아야한다.**
    - **대칭성 : 비교 대상인 두 객체는 동치 여부에 대해 동일한 답을 해야한다.**
    - **추이성 : A 와 B 가 같고 A 와 C 가 같으면, B 와 C 도 같아야한다.**
    - **일관성 : 두 객체가 같다면 변경되지 않는 한 계속 같아야 한다.**
    - **Not Null : 모든 객체는 Null과 같지 않아야 한다.**

- **재정의 할 이유가 없는 경우?**

  - 상위 Collection이나 Value Object를 상속받았을 경우 재정의 하지 않고 사용해도 문제가 없다.
  - 대상 객체가 고유한 인스턴스이다.
  - 논리적인 동치성을 비교할 필요가 없는 경우이다.

<br/>

### HashMap 를 쓸 때 Equals 를 재정의 하는 이유는?

- Map에 값을 넣을 때 Key의 hashCode 는 값이 저장 될 Bucket을 결정하는 데 사용됩니다. 

- 값을 검색하기 위해 HashMap은 hashCode 를 사용하여 동일한 방식으로 버킷을 계산합니다.

- 그런 다음 해당 Bucket에서 찾은 **객체들을 순회하며 Key의 equals () 메서드를 사용**하여 정확하게 일치하는 항목을 찾아야 합니다. 

  - **( HashCode 를 통해 찾은 Bucket 안에 무조건 하나의 값만 있는 경우는 없습니다 )**
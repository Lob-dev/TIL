2020.11.02

<br/>

### Equals를 재정의 해야하는 이유? 

- **논리적인 동치성을 검증해야 할 때.**
    - Custom Class 를 만들었을 때, 해당 Class가 여러개의 인스턴스가 만들어지는 경우에 값을 기준으로 비교해야한다면 Equals 를 재정의 하여야 한다.
    - Equals 를 통해 True를 반환 받았다면, 두 객체는 같은 Hashcode 값을 가져야 한다.
        - **Hashcode도 Equals 와 동일한 규약을 지니고 재정의 되어야한다.**
      - **Object의 hashcode는 객체의 주솟값을 이용하여 Hashcode 를 반환하기에, 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없기 때문이다.**
          - 그래서 내부적으로 값이 같다면 같은 Hashcode 를 가지게 해야한다.

- **재정의 시 지켜야할 규약?**
    - **반사성 : 객체는 자기 자신과 같아야한다.**
    - **대칭성 : 비교 대상인 두 객체는 동치 여부에 대해 동일한 답을 해야한다.**
    - **추이성 : A 와 B 가 같고 A 와 C 가 같으면, B 와 C 도 같아야한다.**
    - **일관성 : 두 객체가 같다면 변경되지 않는 한 계속 같아야 한다.**
    - **Not Null : 모든 객체는 Null과 같지 않아야 한다.**

- **재정의 할 이유가 없는 경우?**

  - 상위 Collection이나 Value Object를 상속받았을 경우 재정의 하지 않고 사용해도 문제가 없다.
  - 대상 객체가 고유한 인스턴스이다.
  - 논리적인 동치성을 비교할 필요가 없는 경우이다.

<br/>

### HashMap 를 쓸 때 Equals 를 재정의 하는 이유는?

- Map에 값을 넣을 때 Key의 hashCode 는 값이 저장 될 Bucket을 결정하는 데 사용됩니다. 

- 값을 검색하기 위해 HashMap은 hashCode 를 사용하여 동일한 방식으로 버킷을 계산합니다.

- 그런 다음 해당 Bucket에서 찾은 **객체들을 순회하며 Key의 equals () 메서드를 사용**하여 정확하게 일치하는 항목을 찾아야 합니다. 

- **String 같은 클래스의 Equals는 반환되는 해시코드가 같다면 동일한 객체로 판단하기 때문에 여러 객체 타입이 저장되는 HashMap 에선 이 방식으로 정확한 값을 찾을 수 없다.** 

- **(해시 충돌 시 찾은 Bucket 안에 여러개의 값이 존재하겠지만, 제일 처음 값을 반환할 것이기 때문에)**
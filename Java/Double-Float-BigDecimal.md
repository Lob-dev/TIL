2020.10.29

<br/>

**JAVA는** **부동 소수점 방식**이며 대부분 **IEEE 754 표준**을 사용한다.

Float 은 **부호 1 bit, 지수 8 bit, 가수 23 bit ( 32bit = float ) 와 같이 배분**한다.

- **부호** 비트 : **양수**인지 **음수**인지 판단.
- **지수** 비트 : **0~255의 값**을 **양수와 음수**를 나누어 **표현**한다. **( -127 ~ 128 )**
- **가수** 비트 : 지수 부분에서 정해진 대략적인 값을 이용해 목표 값에 가까운 수를 표현한다

**Ex) 13.75 이라는 값 표현 ( float 기준 )**

**부호 비트 : 양수이므로 0**

**지수 비트 : $2^n$ 만큼 증가하므로 13.75 를 넘지 않게 $2^3 = 8$ 양수를 사용하려면 + 127을 해야한다.**           

          3 + 127 = 130 = **1000 0010  ( 130 - 127 = 3 )** 

**가수 비트 : 지수 비트의 값을 기준으로 1비트 뒤로 갈수록  / 2  (4, 2, 1, 0.5, 0.25...)** 

           **4 + 1 + 0.5 + 0.25 = 5.75 = 1011 1000 0000 0000 0000 000** 
           **0  1000 0010  1011 1000 0000 0000 0000 000 = 13.75** 

<br/>

**Double 은 부호 1bit, 지수 11 bit, 가수 52 bit 와 같이 배분한다. ( 64bit )**

- **부호** 비트 : **양수**인지 **음수**인지 판단.
- **지수** 비트 : **0~2048의 값**을 **양수와 음수**를 나누어 **표현**한다. **( -1023 ~ 2047 )**
- **가수** 비트 : 지수 부분에서 정해진 대략적인 값을 이용해 목표 값에 가까운 수를 표현한다.

 <br/>

**Java 의 Double, Float를 통한 실수 연산이 부정확한 이유.**

- (**10진수의**) **무한, 순환, 유한소수들은 2진수로 표현할 방법이 없다.**
- **위의 경우** 표시할 수 있는 범위가 넘어갈 경우 근사한 값을 나타내기 위해 **반올림하게 되는데,**   결국 그건 **근삿값**이지 **실제 값**과 **다르다.**
- 10의 음의 거듭 제곱수 ( $10^1, 10^2..$ ) 들을 표현할 수 없다.

<br/>

**BigDecimal 이 상대적으로 정확한 이유? ( Decimal128 Spec )**

- 내부적으로 10진수를 사용하며, 최대 34자리까지의 10진수를 저장, 계산할 수 있다.
- 2진수에서 표현할 수 없는 것 (10진수의 유한소수 등) 들도 자릿수 내에서 확실한 값을 도출한다.

<br/>

BigDecimal 도 전 세계의 통화를 처리하긴 어려움이 있을 수 있어 다른 라이브러리도 존재한다.

(통화의 자릿수가 많다던지..?)

JavaMoney Library

[JavaMoney/jsr354-api](https://github.com/JavaMoney/jsr354-api)
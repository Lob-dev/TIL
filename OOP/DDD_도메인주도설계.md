2020.11.20

도메인주도설계란?

**소프트웨어 개발과 소프트웨어 사용자의 세계를 연결하기 위한 페러다임.**

<br/>

소프트웨어 사용자가 필요한 지식에 대해 고찰하고 문제를 해결하기 위한 수단이자, 지식에 초점을 맞춰 설계하는 기법을 말한다.

**회계 시스템 - 회계 도메인**

- 금전
- 장부 등

**물류 시스템 - 물류 도메인**

- 창고
- 화물
- 운송수단 등

**우선 각 도메인에 따른 개념, 지식을 이해한다.**

사용자들이 직면한 문제를 해결하기 위해서는 그 문제를 정확히 이해하여야 하고, 그 문제를 이해하기 위해서는 그들의 관점, 생각, 환경을 이해하여야 한다. 그것이 즉 도메인이다.

<br/>

**도메인 모델링?**

모델은 현실에서 일어나는 사건, 개념을 추상화한 것을 말하며, 모델링은 사건 혹은 개념을   추상화하는 작업을 말한다. (즉 모델링의 결과물이 모델이다.)

모델도 기능적, 물리적 관점에 따라 필요한 성질이 다르다 (어떤 행위, 어떻게 구성되었다. 등)

도메인 모델이란 관련 도메인의 개념을 모델링이라는 작업을 통해 모델로 변환한 것이다.

<br/>

**도메인 객체?**

도메인 모델은 결국 개념을 추상화 한 것 뿐이며, 이것을 표현, 구현하여서 문제를 해결하도록 하여야한다. 도메인 모델을 소프트웨어 상의 동작하는 모듈로 나타낸 것이 도메인 객체이다.

도메인 객체가 도메인 모델을 충실히 반영하고 있다면, 도메인의 변화를 코드로 쉽게 옮기고 수정할 수 있어야 한다.

**도메인의 변화는 연쇄적으로 도메인 객체까지 영향을 주게 된다.**

반대로 도메인 객체가 도메인에 대한 태도를 변화시키는 경우도 있다. **(모호한, 애매한 개념)**

<br/>

**Flow**

**도메인의 변화 ←→ 도메인 모델의 변화 ←→ 도메인 객체의 변화 (기존과 변화한 것을 비교)**

<br/>

**값 객체란?**

그 도메인만의 고유의 개념을 값으로 나타내는 패턴, 객체이다. (금전, 제조번호, 이름)  원시 변수도 이름과 리터럴을 통해 나타내는 값을 나타내는 요소이지만, 어떠한 객체에 유사한 값 변수를 지님으로써 값 객체로써 동작해야하는 경우도 있다.

**ex) FullName 객체 내부의 프로퍼티 (First Name variable, Last Name variable)**

<br/>

**값의 성질?**

- **불변이다.**

    **변수의 리터럴을 바꾸는 것은 값을 수정하는 것이 아니라 새로운 값을 담는 것이다.**

    - 버그의 원인 중에는 의도치 않은, 감지하지 못한 상태의 변화도 한 몫을 한다.

        **이것을 방지하는 가장 단순한 방법은 상태를 변화하지 않게 하는 것이다.**

        **그리고 이러한 방법은 프로그램을 단순하게 만들 가능성이 있는 제약이다.**

        물론 단점도 있다. 대표적으로 **값을 바꾸고 싶을 때에는 새로운 값을 생성**하여,   **참조, 대입하여야 한다는 것**이다. (새로운 객체의 생성, String 이 한 예)

        이런 경우에는 **가변 객체에 비해서 성능 면에서 불리할 수 있다.** 하지만, 그렇지     않은 경우를 잘 생각해서 **불변객체를 우선적으로 도입하는 것이 더 안전하다.**

        (Date API, SimpleDateFormat은 왜 LocalDate 등으로 대체 되었는지 고민하자.)

- **주고받을 수 있다.**

    값 자체로는 불변일지라도, (참조 중인) 값을 수정해야할 필요는 있다.

    - = 리터럴; , = new ValueObject(리터럴, 리터럴) 와 같이 대입하는 것을 말한다.
- **등등성을 비교할 수 있다.**

    숫자끼리. 문자끼리와 같이 같은 종류의 값은 비교할 수 있다.

    - 0 == 0, "str" == "str" 등은 다른 인스턴스로 보일 수 있지만 (최적화를 제외하고)

        이것들은 값 자신(식별 값, 참조 값) 으로 비교하는 것이 아니라 **값의 구성하는     속성을 통해 비교**된다. (값을 통한 동등성 비교, 재정의 된 VO의 Equals 등)

        **값 객체를 비교할 때는 속성을 꺼내어 비교하는 것보단 객체끼리 비교하는 것이 자연스럽다. ( Object.equals(Object2) )**

        **Equals 를 수정함으로써** **별도의 속성을 추가하더라도** 해당 객체가 사용되는 모든 영역에서 코드를 수정하지 않고 **내부의 메서드 하나만으로 수정의 범위를 제한   시킬 수 있다.**  **(객체 외부에 별도의 비교를 위한 메서드가 있는 경우를 의미)**

<br/>

**이러한 성질은 값 객체에도 그대로 적용되어야 한다.**

추가적으로 값 객체는 값만을 담고있는 것이 목적이 아니다. 가지고 있는 목적에 대하여서,   자신만의 규칙과 행위를 한 곳에 모아두어야 한다. (도메인 객체이다.)

-추가 예정-
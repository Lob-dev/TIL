2020.12.05

### SDP (Stable Dependencies Principle)


**구성 요소가 더 안정적인 다른 구성 요소에 의존하는 방식으로 소프트웨어를 설계하여야한다**

→ 자주 변경해야하는 구성 요소를 쉽게 변경할 수 있고 구성 요소들이 의존하는 안정적인   구성 요소는 변경되지 않을 수 있다.

<br/>

설계는 결코 변하지 않을 수 없으며, 보통 CCP 등의 원칙을 이용함으로써 변동성을 지니도록 설계하게 된다.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 안된다.

한번 의존하게 되면, 변동성이 큰 컴포넌트도 변경이 어려워진다. (강한 결합이 이루어지기에)

**어떤 객체, 컴포넌트가 변경되기 쉽게 설계되더라도 의존성을 가지게 된다면 변경이 어려워진다.**

<br/>

**컴포넌트의 안정성을 측정하는 방법은 이렇다고 한다.**

- 안으로 들어오는 의존성의 개수 (Fan-in) [해당 클래스를 의존하는 외부 클래스들의 수]
- 바깥으로 나가는 의존성의 개수 (Fan-out) [해당 클래스가 의존하는 외부 클래스들의 수]
- 불안정성 = Fan-out / (Fan-in+Fan-out) [0에 가까울수록 안정, 1에 가까울수록 불안정적]

<br/>

**모든 것을 하나의 의존성들 기준으로 작성해보았다.**

컨트롤러는 Service 혹은 Repository에 의존적이다. 하지만 컨트롤러를 의존하는 다른 코드는 존재하지 않는다. 

**→ 하나의 컨트롤러는 최고로 불안정한 상태를 가진다. [ 1 / (0 + 1) = 1 ]** 

<br/>

Service는 Repository를 의존한다. Controller는 Service를 의존한다.

**→ 하나의 서비스는 안정적인 상태와 불안정적인 상태의 중간에 위치한다. [ 1 / (1 + 1) = 0.5 ]**

<br/>

Repository는 어떠한 것도 의존하지 않는다. Controller와 Service는 Repository를 의존한다.

**→ 하나의 Repository 는 매우 안정적인 상태를 가지게 된다. [ 0 / (2 + 0) = 0 ]**

<br/>

**이러한 값들을 본다면 Service는 컨트롤러를 의존하면 안되고, Repository는 컨트롤러와 서비스를 의존하면 안된다는 것을 알 수 있다.**

**물론 이러한 구조는 매우 안정적이지만 설계의 유연성을 떨어트릴 수 있다고 한다.**

(변경되지 않거나, (변경되기)쉽지 않은 구조이기 때문이다)

<br/>

**이것을 해결하기 위해서는 Stable Abstraction Principle 을 적절히 혼용하여야 한다.**
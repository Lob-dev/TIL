2021.01.19 


### **JWT**

JSON 객체를 사용하여 토큰 자체에 정보들을 저장하고 있는 Web Token이다.

간편하게 구현하고 쉽게 적용할 수 있다.

<br/>

**JWT 구조?**

---

**Header**

Signature를 Hashing하기 위한 알고리즘 정보가 담겨있다.

```jsx
{
  "alg" : "{HS512}",
	"typ" : "JWT"
}
```

<br/>

**Payload (Claims)**

서버와 클라이언트가 주고받는, 시스템에서 사용될 정보들을 담고있다.

```jsx
{
	"iss" : "..." // 토큰 발행자
	"sub" : "..." // 토큰 주제
  "aud" : "..." // 토큰 사용자
  "exp" : "..." // Unix 시간에 정의 된 JWT 만료 시간
  "nbf" : "..." // 토큰 발행 시간 (Unix)
  "jti" : "..." // JWT 고유 식별자 
}

// example
{
	"iss" : "lob.com",
  "exp" : 1426420800,
  "https://www.example.com/jwt_claims/is_admin": true,
  "company" : "none",
  "awesome" : "true"
}
```

- Token의 Metadata
- Entity 정보 등

<br/>

**Signature**

토큰의 유효성 검증을 위한 문자열을 가지고 있다. 해당 내용을 이용하여 서버는 토큰의 유효성 검증을 진행한다.

*Header와 Payload를 합친뒤 인코딩하여 서버가 가진 시크릿 키를 통해 암호화한 것이다.*

<br/>

**JWT 장점**

---

- 중앙의 인증서버, 데이터 스토어에 대한 의존성이 없으며, 시스템 수평 확장에 유리하다.
    - 서버는 해당 정보를 관리하지 않기에 로드 밸런서와 같은 분산 처리 시스템이 도입된 시스템에서도 문제없이 사용할 수 있다.
- 구성 요소에 대해 Base64 URL Safe Encoding가 사용되어있다.
- 범위와 시간을 제한할 수 있으므로, 쿠키보다 세분화 된 사용이 가능하다.
- 하나의 토큰을 별도 설정없이도 여러 서버 인스턴스와 원활한 통신이 가능하다.
- CSRF(Cross-Site Request Forgery) 공격으로부터 보호할 필요가 없다.
- 각 요청에 대한 세션을 찾고 역 직렬화 하는 등의 로직이 존재하지 않음으로 상대적으로 서버 자원을 적게 사용한다. (물리적인 자원 : 성능)

<br/>

**CSRF(Cross-Site Request Forgery) 란?**

---

인증된 사용자를 속여 공격자가 선택한 작업을 실행하도록 할 수 있다. 

이는 피해자의 정보, 세션 쿠키 등 자격 증명 정보를 이용한다는 것을 의미한다.

*개인 사용자의 경우 금액 이체, 개인 정보 변경 등, 관리자의 경우 더 큰 범위의 공격이 가능해진다.* 

<br/>

**방어 방법**

- **Referrer 속성 검증**

    Request 에 대하여서 해당 속성을 검증하고 차단한다. 이는 같은 도메인 상에서의 요청이 아닌 이상 차단할 수 있는 방법이다.

- **CRSF Token 사용**

    사용자의 세션에 Token을 만들어 Binding하고 모든 요청에 대해서 해당 Token이 있는지 검증하는 방식

- **CAPTCHA 사용**

    CAPTCHA 이미지상의 숫자, 문자가 같지 않다면 해당 요청을 거부하는 방식.

- **Form 작성시 post 방식 사용 등**

<br/>

**JWT 단점** 

---

- **Payload의 정보가 많아지면 네트워크 사용량이 증가한다. → 데이터 설계가 고려되야 함**
- **토큰이 클라이언트에 저장되기에 서버에서 해당 토큰을 조작할 수 없다.**

- **세션과 달리 한 번 발급된 토큰을 무력화시킬 수 없다.**
    - 즉 로컬 스토리지, 쿠키에 접근하여 JWT를 탈취한다면 접근을 차단할 방법이 없다.

        *JWT가 만료될 때까지 기다려야한다.*

<br/>

**JWT 보안, 암호화 방식**

---

- **TLS, SSL 사용**
- **JWE (JSON WEB Encryption) 사양 사용 (: 오버헤드가 발생한다. )**

    [https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-40](https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-40)

<br/>

**JWT Token Flow**

---

1. Client는 사용자 로그인 정보를 포함하는 인증 서버에 요청을 보낸다.
2. 인증 서버는 새로운 JWT Token을 생성하고 이를 결과로 반환한다.
3. Client는 해당 Token을 로컬 스토리지, 쿠키 저장소에 저장한다.
4. 제한된 자원 요청들에 대하여서 클라이언트는 QueryString 혹은 Authorization 헤더에 Token을 담아 보낸다
5. 서버는 암호화 키를 이용하여 해당 Token의 유효성을 검증하고 유효한 경우 자원을 Client에게 전달한다.

    *이 때 해당 Token이 탈취된 상태라면 보안취약점이 발생하는 것이다.*

*인증 서버의 검증 방식은 대칭키 알고리즘과 비대칭 키 알고리즘 상관없이 이용할 수 있다.*

<br/>

**JWT를 적용한 이유 : 서버 기반 인증의 단점**

---

- **불편한 확장**

    서버는 사용자에 대한 세션을 어딘가에 유지하고 있어야한다. 이는 Memory, DB 등 어디서든 수행되어야할 필수적인 행위이다. 

    *(서버간의 세션 공유를 위해서는 별도의 세션 저장소 [외부 스토리지를 사용하여야 한다.])*

- **CORS (Cross-origin request sharing)**

    AJAX 호출을 사용하여 다른 도메인의 자원을 가져오는 경우 Origin에 대한 처리가 되어있지 않다면 문제가 발생할 수 있다. 

    (Spring Framework에서는  @CrossOrigin 을 사용하여 해당 문제를 해결할 수 있다.)

- **웹 프레임워크와의 결합성**

    서버 기반의 인증을 사용한다면 프레임워크의 인증 체계와 결합되게 되는데, 이는 다른 언어, 프레임워크로 구현된 API 간의 세션 데이터를 공유하는 것의 어려움을 초래한다.
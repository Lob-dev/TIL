2020.10.19

<br/>

Spring이 왜 경량프레임워크를 표명하였는지 알기 위해 그 이전에 사용되었던 기술인 **EJB (Enterprise Java Bean)** 를 알아보았다.

EJB는 Java Bean이라는 개념을 도입하여 ****

- **각 객체를 컴포넌트 단위로 분리**하고
- 객체 의존관계의 해결을 위해 **컨테이너를 통해 해당 객체들을 관리**하였으며,
- **자동 설정과 선언적 트랜잭션 처리,**
- 사용 상태를 확인하여 **메모리 상에서 객체를 비활성화** 한다던지
- **각 계층을 분산하여** 성능을 끌어내는 등

**정말 다양한 기술들을 기본적으로 지원**해준 **스펙(표준 기술)**이다. 

<br/>

해당 내용만을 들어보면 정말 좋은 기술인 것 같은데 왜 사용하지 않을까?

- 기본적으로 사용되는 Java Bean에 대하여서 설정을 진행할 때 **EJB 스펙을 지키기 위해**   **인터페이스를 구현하고, 여러 클래스를 상속 받고**, 그에 맞게 **구현하면서** **실제 비즈니스 로직보다** **EJB 컨테이너를 사용하기 위한 코드가 많아지는 현상**이 **발생**하였다.                     (주객이 전도되었다.)
- 위와 같은 상황으로 인해 객체들은 **EJB 컨테이너 위에서만 인스턴스화가 가능**하였고,    **쓸데없는 의존성**에 의하여 로드, 사용시에 정말 무겁게 동작하였다. (성능이.. 좋지 않다.)
- 위의 의존성 문제 때문에 **단위 테스트가 불가능**하였다. (테스트를 하기 위해선, 컨테이너를 띄워놓고 진행하여야 하는데, 모든 서비스를 띄우게 되기 때문에 정말 느렸다.)

즉 기술의 급격한 발전과 오버 엔지니어링 때문에 무거운, 복잡한, 거대한, 종속적인 기술들이 되어갔다.

<br/>

Spring 은 이 문제를 비판하고 단순함을 강조했던 **expert one-on-one J2EE Design and Development** 이라는 저서를 고스란히 물려받아 탄생한 것이다. 

Spring은 XML, Annotation 기반의 Configuration 을 통해 빈을 등록하고 관리해주는 컨테이너, 순수한 객체(POJO) 기반의 Spring Bean , CoC를 통한 유연하고 쉬운 선언적 방식과 PSA 라는 것을 반영함으로써 여러 프레임워크, 라이브러리, 구현체에 대하여서 인터페이스를 제공하여서 문제없이 작동하게하고 확장성을 늘렸으며, 공통 부분의 소스 코딩과 로직에만    집중하게끔 만들어낸 오픈소스 프레임워크이다. 

Spring은 EJB의 복잡성을 해결하면서 같은 기능을 제공하기에 가볍다고 하는 것이 아닐까?